<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comentarios en PDF</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Efectos de confeti */
        .confetti {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff6b6b;
            animation: confetti-fall 3s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Estilos para comentarios aprobados */
        .comment-approved {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-left-color: #28a745 !important;
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.15);
        }

        .comment-approved .approval-badge {
            background: #28a745;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        /* Estilos para respuestas */
        .comment-reply {
            margin-left: 20%;
            border-left: 3px solid #e9ecef;
            background: #f8f9fa;
        }

        /* Estilos para el editor de texto enriquecido */
        .rich-text-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            background: #f9fafb;
            border-radius: 8px 8px 0 0;
        }

        .toolbar-button {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #374151;
            transition: all 0.2s;
        }

        .toolbar-button:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .toolbar-button.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        /* Estilos para contenido enriquecido */
        .rich-content strong {
            font-weight: bold;
        }

        .rich-content em {
            font-style: italic;
        }

        .rich-content a {
            color: #3b82f6;
            text-decoration: underline;
        }

        .rich-content img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin: 8px 0;
        }

        .rich-content .youtube-embed {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            margin: 8px 0;
            border-radius: 8px;
        }

        .rich-content .youtube-embed iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;
        
        // Iconos usando SVG inline
        const MessageCircle = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="m3 21 1.9-5.7a8.5 8.5 0 1 1 3.8 3.8z"/>
            </svg>
        );
        
        const Download = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7,10 12,15 17,10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );
        
        const Edit3 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 20h9"/>
                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/>
            </svg>
        );
        
        const Trash2 = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3,6 5,6 21,6"/>
                <path d="m19,6v14a2,2 0 0,1 -2,2H7a2,2 0 0,1 -2,-2V6m3,0V4a2,2 0 0,1 2,-2h4a2,2 0 0,1 2,2v2"/>
                <line x1="10" y1="11" x2="10" y2="17"/>
                <line x1="14" y1="11" x2="14" y2="17"/>
            </svg>
        );

        const ReplyIcon = ({ size = 16 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="9,17 4,12 9,7"/>
                <path d="M20 18v-2a4 4 0 0 0-4-4H4"/>
            </svg>
        );

        const CheckCircle = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/>
                <polyline points="22,4 12,14.01 9,11.01"/>
            </svg>
        );

        // Funciones auxiliares para confeti
        const createConfetti = () => {
            const confettiContainer = document.createElement('div');
            confettiContainer.className = 'confetti';
            document.body.appendChild(confettiContainer);

            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98fb98'];
            
            for (let i = 0; i < 50; i++) {
                const confettiPiece = document.createElement('div');
                confettiPiece.className = 'confetti-piece';
                confettiPiece.style.left = Math.random() * 100 + '%';
                confettiPiece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confettiPiece.style.animationDelay = Math.random() * 3 + 's';
                confettiPiece.style.animationDuration = (Math.random() * 2 + 2) + 's';
                confettiContainer.appendChild(confettiPiece);
            }

            setTimeout(() => {
                document.body.removeChild(confettiContainer);
            }, 5000);
        };

        // Funci√≥n para procesar texto enriquecido
        const processRichText = (text) => {
            if (!text) return '';
            
            // Detectar URLs de YouTube y convertir a embed
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/g;
            text = text.replace(youtubeRegex, (match, videoId) => {
                return `<div class="youtube-embed"><iframe src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe></div>`;
            });

            // Detectar URLs de im√°genes
            const imageRegex = /(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp))/gi;
            text = text.replace(imageRegex, '<img src="$1" alt="Imagen" />');

            // Detectar URLs de Google Drive (convertir a vista directa)
            const driveRegex = /https:\/\/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/g;
            text = text.replace(driveRegex, (match, fileId) => {
                return `<img src="https://drive.google.com/uc?id=${fileId}" alt="Imagen de Google Drive" />`;
            });

            // Detectar enlaces generales
            const linkRegex = /(https?:\/\/[^\s]+)/g;
            text = text.replace(linkRegex, '<a href="$1" target="_blank">$1</a>');

            return text;
        };

        // Componente para el editor de texto enriquecido
        const RichTextEditor = ({ value, onChange, placeholder }) => {
            const [showBold, setShowBold] = useState(false);
            const [showItalic, setShowItalic] = useState(false);
            const textareaRef = useRef(null);

            const insertFormat = (startTag, endTag) => {
                const textarea = textareaRef.current;
                const start = textarea.selectionStart;
                const end = textarea.selectionEnd;
                const selectedText = value.substring(start, end);
                
                if (selectedText) {
                    const newText = value.substring(0, start) + startTag + selectedText + endTag + value.substring(end);
                    onChange(newText);
                } else {
                    const newText = value.substring(0, start) + startTag + endTag + value.substring(end);
                    onChange(newText);
                    // Posicionar cursor entre las etiquetas
                    setTimeout(() => {
                        textarea.focus();
                        textarea.setSelectionRange(start + startTag.length, start + startTag.length);
                    }, 0);
                }
            };

            const insertLink = () => {
                const url = prompt('Introduce la URL:');
                if (url) {
                    const text = prompt('Texto del enlace (opcional):') || url;
                    const textarea = textareaRef.current;
                    const start = textarea.selectionStart;
                    const linkText = `[${text}](${url})`;
                    const newText = value.substring(0, start) + linkText + value.substring(start);
                    onChange(newText);
                }
            };

            return (
                <div className="border border-gray-300 rounded-lg overflow-hidden">
                    <div className="rich-text-toolbar">
                        <button 
                            type="button"
                            className="toolbar-button"
                            onClick={() => insertFormat('**', '**')}
                            title="Negrita"
                        >
                            <strong>B</strong>
                        </button>
                        <button 
                            type="button"
                            className="toolbar-button"
                            onClick={() => insertFormat('*', '*')}
                            title="Cursiva"
                        >
                            <em>I</em>
                        </button>
                        <button 
                            type="button"
                            className="toolbar-button"
                            onClick={insertLink}
                            title="Insertar enlace"
                        >
                            üîó
                        </button>
                        <div className="text-xs text-gray-500 flex items-center ml-2">
                            URLs de im√°genes y YouTube se detectan autom√°ticamente
                        </div>
                    </div>
                    <textarea
                        ref={textareaRef}
                        value={value}
                        onChange={(e) => onChange(e.target.value)}
                        placeholder={placeholder}
                        className="w-full h-32 p-3 resize-none focus:outline-none"
                        style={{ borderRadius: '0 0 8px 8px' }}
                    />
                </div>
            );
        };

        // Componente para mostrar contenido enriquecido
        const RichContent = ({ content }) => {
            if (!content) return null;

            let processedContent = content;

            // Procesar markdown b√°sico
            processedContent = processedContent.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            processedContent = processedContent.replace(/\*(.*?)\*/g, '<em>$1</em>');
            processedContent = processedContent.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2" target="_blank">$1</a>');

            // Procesar multimedia
            processedContent = processRichText(processedContent);

            return (
                <div 
                    className="rich-content"
                    dangerouslySetInnerHTML={{ __html: processedContent }}
                />
            );
        };

        // Componente principal
        const PDFCommentApp = () => {
            const [comments, setComments] = useState([]);
            const [isDrawing, setIsDrawing] = useState(false);
            const [currentRect, setCurrentRect] = useState(null);
            const [hoveredComment, setHoveredComment] = useState(null);
            const [newComment, setNewComment] = useState('');
            const [showCommentDialog, setShowCommentDialog] = useState(false);
            const [pendingRect, setPendingRect] = useState(null);
            const [editingComment, setEditingComment] = useState(null);
            const [editCommentText, setEditCommentText] = useState('');
            const [project, setProject] = useState(null);
            const [loading, setLoading] = useState(true);
            const [error, setError] = useState(null);
            const [pdfDoc, setPdfDoc] = useState(null);
            const [pageNum, setPageNum] = useState(1);
            const [scale, setScale] = useState(0.90);
            const [debugInfo, setDebugInfo] = useState('');
            const [renderFailed, setRenderFailed] = useState(false);
            const [totalPages, setTotalPages] = useState(0);
            const [isRendering, setIsRendering] = useState(false);
            const [renderedPages, setRenderedPages] = useState([]);
            
            // Estados para respuestas
            const [replyingTo, setReplyingTo] = useState(null);
            const [replyText, setReplyText] = useState('');
            
            const canvasContainerRef = useRef(null);
            const overlaysRef = useRef([]);

            // Obtener UUID del proyecto de la URL
            const getProjectUUID = () => {
                const path = window.location.pathname;
                const parts = path.split('/');
                return parts[parts.length - 1];
            };

            // Cargar PDF.js
            useEffect(() => {
                console.log('üîÑ Cargando PDF.js...');
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js';
                script.onload = () => {
                    console.log('‚úÖ PDF.js cargado exitosamente');
                    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    loadProject();
                };
                script.onerror = () => {
                    console.error('‚ùå Error cargando PDF.js');
                    setError('Error cargando PDF.js');
                    setLoading(false);
                };
                document.head.appendChild(script);
            }, []);

            // Cargar proyecto y PDF
            const loadProject = async () => {
                try {
                    const uuid = getProjectUUID();
                    console.log('üîç UUID obtenido:', uuid);
                    setDebugInfo('Obteniendo UUID: ' + uuid);
                    
                    if (!uuid) {
                        setError('UUID del proyecto no v√°lido');
                        setLoading(false);
                        return;
                    }

                    console.log('üì° Cargando datos del proyecto...');
                    setDebugInfo('Cargando datos del proyecto...');
                    const projectResponse = await fetch(`/api/projects/${uuid}`);
                    const projectData = await projectResponse.json();
                    
                    console.log('üìã Respuesta del proyecto:', projectData);

                    if (!projectData.success) {
                        setError(projectData.error);
                        setLoading(false);
                        return;
                    }

                    setProject(projectData.project);
                    console.log('‚úÖ Proyecto cargado:', projectData.project);
                    setDebugInfo('Proyecto cargado: ' + projectData.project.name);

                    console.log('üîç Verificando acceso al PDF:', projectData.project.pdf_url);
                    setDebugInfo('Verificando PDF: ' + projectData.project.pdf_url);
                    const pdfTestResponse = await fetch(projectData.project.pdf_url, { method: 'HEAD' });
                    console.log('üìÑ Estado del PDF:', pdfTestResponse.status);

                    if (!pdfTestResponse.ok) {
                        throw new Error(`PDF no accesible: ${pdfTestResponse.status}`);
                    }

                    console.log('üìñ Cargando PDF con PDF.js...');
                    setDebugInfo('Cargando PDF con PDF.js...');
                    const loadingTask = window.pdfjsLib.getDocument({
                        url: projectData.project.pdf_url,
                        withCredentials: false,
                        isEvalSupported: false,
                        disableAutoFetch: false,
                        disableStream: false
                    });
                    
                    const pdf = await loadingTask.promise;
                    setPdfDoc(pdf);
                    setTotalPages(pdf.numPages);
                    console.log('‚úÖ PDF cargado exitosamente, p√°ginas:', pdf.numPages);
                    setDebugInfo('PDF cargado: ' + pdf.numPages + ' p√°ginas');

                    await loadComments(uuid);
                    
                    setLoading(false);
                    setDebugInfo('PDF cargado, esperando renderizado autom√°tico...');
                    console.log('üéâ PDF cargado, esperando renderizado autom√°tico');
                } catch (err) {
                    console.error('‚ùå Error cargando proyecto:', err);
                    setError('Error al cargar el proyecto: ' + err.message);
                    setDebugInfo('‚ùå Error: ' + err.message);
                    setLoading(false);
                }
            };

            // Cargar comentarios del proyecto
            const loadComments = async (uuid) => {
                try {
                    const response = await fetch(`/api/projects/${uuid}/comments`);
                    const data = await response.json();
                    
                    if (data.success) {
                        setComments(data.comments);
                    }
                } catch (err) {
                    console.error('Error cargando comentarios:', err);
                }
            };

            // Renderizar todas las p√°ginas del PDF
            const renderAllPages = async (pdf, retryCount = 0) => {
                try {
                    if (isRendering) {
                        console.log('‚è≥ Ya hay un renderizado en progreso, esperando...');
                        return;
                    }

                    setIsRendering(true);
                    console.log('üé® Renderizando todas las p√°ginas del PDF...');
                    setDebugInfo('Renderizando todas las p√°ginas...');

                    const container = canvasContainerRef.current;
                    if (!container) {
                        console.error('‚ùå Container ref no encontrado');
                        if (retryCount < 3) {
                            setIsRendering(false);
                            setTimeout(() => renderAllPages(pdf, retryCount + 1), 500);
                            return;
                        }
                        setIsRendering(false);
                        throw new Error('Container no disponible despu√©s de varios intentos');
                    }

                    container.innerHTML = '';
                    overlaysRef.current = [];
                    setRenderedPages([]);

                    const pages = [];
                    
                    for (let pageNumber = 1; pageNumber <= pdf.numPages; pageNumber++) {
                        console.log(`üé® Renderizando p√°gina ${pageNumber}/${pdf.numPages}`);
                        setDebugInfo(`Renderizando p√°gina ${pageNumber}/${pdf.numPages}...`);

                        const page = await pdf.getPage(pageNumber);
                        const viewport = page.getViewport({ scale });

                        const pageContainer = document.createElement('div');
                        pageContainer.className = 'page-container relative mb-4 bg-white shadow-lg mx-auto';
                        pageContainer.style.cssText = `
                            position: relative;
                            width: ${viewport.width}px;
                            height: ${viewport.height}px;
                            margin-bottom: 16px;
                            background: white;
                            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
                            margin-left: auto;
                            margin-right: auto;
                        `;

                        const canvas = document.createElement('canvas');
                        canvas.width = viewport.width;
                        canvas.height = viewport.height;
                        canvas.style.cssText = `
                            display: block;
                            width: ${viewport.width}px;
                            height: ${viewport.height}px;
                            position: relative;
                            z-index: 1;
                        `;

                        const overlay = document.createElement('div');
                        overlay.className = 'absolute top-0 left-0 cursor-crosshair';
                        overlay.style.cssText = `
                            position: absolute;
                            top: 0;
                            left: 0;
                            width: ${viewport.width}px;
                            height: ${viewport.height}px;
                            pointer-events: auto;
                            z-index: 10;
                        `;
                        overlay.dataset.pageNumber = pageNumber;

                        overlay.addEventListener('mousedown', (e) => {
                            handleMouseDown(e, pageNumber);
                        });

                        const context = canvas.getContext('2d');
                        const renderContext = {
                            canvasContext: context,
                            viewport: viewport
                        };

                        await page.render(renderContext).promise;

                        pageContainer.appendChild(canvas);
                        pageContainer.appendChild(overlay);
                        container.appendChild(pageContainer);

                        pages.push({
                            pageNumber,
                            canvas,
                            overlay,
                            container: pageContainer,
                            viewport
                        });
                        overlaysRef.current[pageNumber - 1] = overlay;

                        console.log(`‚úÖ P√°gina ${pageNumber} renderizada`);
                    }

                    setRenderedPages(pages);
                    setRenderFailed(false);
                    setDebugInfo(`PDF renderizado correctamente`);
                    setIsRendering(false);

                    console.log('üéâ Todas las p√°ginas renderizadas exitosamente');
                    
                    setTimeout(() => {
                        drawCommentRectangles();
                    }, 200);

                } catch (err) {
                    console.error('‚ùå Error renderizando p√°ginas:', err);
                    setDebugInfo('‚ùå Error en renderizado: ' + err.message);
                    setIsRendering(false);
                    
                    if (retryCount < 2) {
                        console.log('üîÑ Reintentando renderizado en 1 segundo...');
                        setTimeout(() => renderAllPages(pdf, retryCount + 1), 1000);
                    } else {
                        setError('Error al renderizar el PDF: ' + err.message);
                        setRenderFailed(true);
                    }
                }
            };

            // Organizar comentarios en estructura jer√°rquica
            const organizeComments = (comments) => {
                const organized = [];
                const commentMap = {};
                
                // Crear mapa de comentarios
                comments.forEach(comment => {
                    commentMap[comment.id] = { ...comment, replies: [] };
                });
                
                // Organizar en estructura padre-hijo
                comments.forEach(comment => {
                    if (comment.parent_id) {
                        // Es una respuesta
                        if (commentMap[comment.parent_id]) {
                            commentMap[comment.parent_id].replies.push(commentMap[comment.id]);
                        }
                    } else {
                        // Es un comentario principal
                        organized.push(commentMap[comment.id]);
                    }
                });
                
                return organized;
            };

            // Dibujar rect√°ngulos de comentarios
            const drawCommentRectangles = () => {
                if (!overlaysRef.current.length) return;

                overlaysRef.current.forEach(overlay => {
                    if (overlay) {
                        const children = Array.from(overlay.children);
                        children.forEach(child => {
                            if (!child.classList.contains('drawing-rect')) {
                                overlay.removeChild(child);
                            }
                        });
                    }
                });

                // Solo dibujar comentarios principales (sin parent_id)
                const mainComments = comments.filter(comment => !comment.parent_id);
                const commentsByPage = {};
                mainComments.forEach((comment, index) => {
                    const page = comment.page || 1;
                    if (!commentsByPage[page]) commentsByPage[page] = [];
                    commentsByPage[page].push({ ...comment, globalIndex: index });
                });

                Object.keys(commentsByPage).forEach(pageStr => {
                    const pageNumber = parseInt(pageStr);
                    const pageComments = commentsByPage[pageNumber];
                    const overlay = overlaysRef.current[pageNumber - 1];
                    
                    if (!overlay) return;

                    pageComments.forEach(comment => {
                        const rect = document.createElement('div');
                        rect.className = `absolute border-2 cursor-pointer transition-all duration-200 comment-rect ${
                            hoveredComment === comment.globalIndex ? 'border-red-500 border-4 z-20' : 'border-blue-500'
                        }`;
                        rect.style.left = comment.rect.x + 'px';
                        rect.style.top = comment.rect.y + 'px';
                        rect.style.width = comment.rect.width + 'px';
                        rect.style.height = comment.rect.height + 'px';
                        rect.style.borderColor = comment.color;
                        rect.style.backgroundColor = hoveredComment === comment.globalIndex ? comment.color + '20' : 'transparent';
                        rect.style.pointerEvents = 'none';

                        const number = document.createElement('div');
                        number.className = 'absolute -top-6 left-0 w-6 h-6 rounded-full text-white text-xs flex items-center justify-center font-bold';
                        number.style.backgroundColor = comment.color;
                        number.style.pointerEvents = 'none';
                        number.textContent = comment.globalIndex + 1;
                        
                        rect.appendChild(number);
                        overlay.appendChild(rect);
                    });
                });

                if (isDrawing && currentRect && currentRect.overlay) {
                    let drawingRect = currentRect.overlay.querySelector('.drawing-rect');
                    
                    if (!drawingRect) {
                        drawingRect = document.createElement('div');
                        drawingRect.className = 'drawing-rect absolute border-2 border-blue-500 border-dashed pointer-events-none bg-blue-100 bg-opacity-20';
                        currentRect.overlay.appendChild(drawingRect);
                    }

                    const left = Math.min(currentRect.startX, currentRect.startX + currentRect.width);
                    const top = Math.min(currentRect.startY, currentRect.startY + currentRect.height);
                    const width = Math.abs(currentRect.width);
                    const height = Math.abs(currentRect.height);

                    drawingRect.style.left = left + 'px';
                    drawingRect.style.top = top + 'px';
                    drawingRect.style.width = width + 'px';
                    drawingRect.style.height = height + 'px';
                }
            };

            // Efecto para renderizar cuando el PDF est√© listo
            useEffect(() => {
                if (pdfDoc && canvasContainerRef.current && !loading) {
                    console.log('üîÑ PDF y contenedor listos, iniciando renderizado autom√°tico...');
                    setDebugInfo('Contenedor listo, renderizando todas las p√°ginas...');
                    
                    setTimeout(() => {
                        renderAllPages(pdfDoc);
                    }, 500);
                    
                    setTimeout(() => {
                        if (renderFailed || debugInfo.includes('esperando')) {
                            console.log('üîÑ Segundo intento autom√°tico de renderizado...');
                            renderAllPages(pdfDoc);
                        }
                    }, 2000);
                }
            }, [pdfDoc, loading]);

            useEffect(() => {
                if (renderedPages.length > 0) {
                    drawCommentRectangles();
                }
            }, [comments, hoveredComment, renderedPages]);

            // Manejar selecci√≥n de √°rea
            const handleMouseDown = (e, pageNumber) => {
                if (isDrawing) return;

                e.preventDefault();
                e.stopPropagation();

                const overlay = e.currentTarget;
                const rect = overlay.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const drawingRect = document.createElement('div');
                drawingRect.className = 'drawing-rect-temp';
                drawingRect.style.cssText = `
                    position: absolute;
                    border: 2px dashed blue;
                    background: rgba(0, 0, 255, 0.1);
                    pointer-events: none;
                    z-index: 999;
                    left: ${x}px;
                    top: ${y}px;
                    width: 0px;
                    height: 0px;
                `;
                overlay.appendChild(drawingRect);

                setIsDrawing(true);
                setCurrentRect({ 
                    x, 
                    y, 
                    width: 0, 
                    height: 0, 
                    page: pageNumber,
                    startX: x,
                    startY: y,
                    overlay: overlay,
                    drawingElement: drawingRect
                });

                const handleGlobalMouseMove = (e) => {
                    const rect = overlay.getBoundingClientRect();
                    const currentX = e.clientX - rect.left;
                    const currentY = e.clientY - rect.top;

                    const newWidth = currentX - x;
                    const newHeight = currentY - y;

                    const left = Math.min(x, currentX);
                    const top = Math.min(y, currentY);
                    const width = Math.abs(newWidth);
                    const height = Math.abs(newHeight);

                    drawingRect.style.left = left + 'px';
                    drawingRect.style.top = top + 'px';
                    drawingRect.style.width = width + 'px';
                    drawingRect.style.height = height + 'px';

                    setCurrentRect(prev => ({
                        ...prev,
                        width: newWidth,
                        height: newHeight
                    }));
                };

                const handleGlobalMouseUp = (e) => {
                    document.removeEventListener('mousemove', handleGlobalMouseMove);
                    document.removeEventListener('mouseup', handleGlobalMouseUp);
                    
                    drawingRect.remove();
                    setIsDrawing(false);

                    setCurrentRect(current => {
                        if (!current) return null;

                        if (Math.abs(current.width) > 10 && Math.abs(current.height) > 10) {
                            const normalizedRect = {
                                x: Math.min(current.startX, current.startX + current.width),
                                y: Math.min(current.startY, current.startY + current.height),
                                width: Math.abs(current.width),
                                height: Math.abs(current.height),
                                page: current.page
                            };

                            setPendingRect(normalizedRect);
                            setShowCommentDialog(true);
                        }

                        return null;
                    });
                };

                document.addEventListener('mousemove', handleGlobalMouseMove);
                document.addEventListener('mouseup', handleGlobalMouseUp);
            };

            const scrollToComment = (comment) => {
                if (!comment.page || !renderedPages.length) return;
                
                const pageData = renderedPages.find(p => p.pageNumber === comment.page);
                if (!pageData) return;

                const commentY = pageData.container.offsetTop + comment.rect.y;
                const container = canvasContainerRef.current?.parentElement;
                
                if (container) {
                    container.scrollTo({
                        top: commentY - 100,
                        behavior: 'smooth'
                    });
                }
            };

            const addComment = async (parentId = null) => {
                const text = parentId ? replyText : newComment;
                if (!text.trim()) return;

                let rectToUse = pendingRect;
                
                // Si es una respuesta, usar el rect√°ngulo del comentario padre
                if (parentId) {
                    const parentComment = comments.find(c => c.id === parentId);
                    if (parentComment) {
                        rectToUse = parentComment.rect;
                    }
                }

                if (!rectToUse || !project) return;

                try {
                    const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336'];
                    
                    const response = await fetch(`/api/projects/${project.uuid}/comments`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: text,
                            rect: rectToUse,
                            color: colors[comments.length % colors.length],
                            page: rectToUse.page || 1,
                            parent_id: parentId
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        await loadComments(project.uuid);
                        
                        if (parentId) {
                            setReplyText('');
                            setReplyingTo(null);
                        } else {
                            setNewComment('');
                            setShowCommentDialog(false);
                            setPendingRect(null);
                        }
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    console.error('Error agregando comentario:', err);
                    setError('Error al agregar comentario');
                }
            };

            // Aprobar comentario con confeti
            const approveComment = async (commentId) => {
                try {
                    const response = await fetch(`/api/comments/${commentId}/approve`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({ approved: true })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        createConfetti();
                        await loadComments(project.uuid);
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    console.error('Error aprobando comentario:', err);
                    setError('Error al aprobar comentario');
                }
            };

            // Editar comentario
            const startEditComment = (index) => {
                setEditingComment(index);
                setEditCommentText(comments[index].text);
            };

            const saveEditComment = async () => {
                if (!editCommentText.trim() || editingComment === null) return;

                try {
                    const commentId = comments[editingComment].id;
                    
                    const response = await fetch(`/api/comments/${commentId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            text: editCommentText
                        })
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        await loadComments(project.uuid);
                        setEditingComment(null);
                        setEditCommentText('');
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    console.error('Error editando comentario:', err);
                    setError('Error al editar comentario');
                }
            };

            const cancelEditComment = () => {
                setEditingComment(null);
                setEditCommentText('');
            };

            // Eliminar comentario
            const deleteComment = async (index) => {
                try {
                    const commentId = comments[index].id;
                    
                    const response = await fetch(`/api/comments/${commentId}`, {
                        method: 'DELETE'
                    });

                    const data = await response.json();
                    
                    if (data.success) {
                        await loadComments(project.uuid);
                    } else {
                        setError(data.error);
                    }
                } catch (err) {
                    console.error('Error eliminando comentario:', err);
                    setError('Error al eliminar comentario');
                }
            };

            // Exportar comentarios
            const exportComments = () => {
                const organizedComments = organizeComments(comments);
                
                const data = {
                    project: project.name,
                    totalPages: totalPages,
                    comments: organizedComments.map((c, index) => ({
                        numero: index + 1,
                        texto: c.text,
                        pagina: c.page || 1,
                        area: c.rect,
                        color: c.color,
                        aprobado: c.approved,
                        fecha: c.created_at,
                        respuestas: c.replies.map(r => ({
                            texto: r.text,
                            fecha: r.created_at,
                            aprobado: r.approved
                        }))
                    })),
                    exportDate: new Date().toISOString(),
                    summary: {
                        totalComments: comments.length,
                        approvedComments: comments.filter(c => c.approved).length,
                        commentsByPage: {}
                    }
                };

                // Resumen de comentarios por p√°gina
                comments.forEach(comment => {
                    const page = comment.page || 1;
                    data.summary.commentsByPage[page] = (data.summary.commentsByPage[page] || 0) + 1;
                });

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `comentarios-${project.name}-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
            };

            if (loading) {
                return (
                    <div className="h-screen flex items-center justify-center">
                        <div className="text-center">
                            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-600 mx-auto mb-4"></div>
                            <p className="text-gray-600">Cargando proyecto...</p>
                        </div>
                    </div>
                );
            }

            if (error) {
                return (
                    <div className="h-screen flex items-center justify-center">
                        <div className="text-center">
                            <div className="text-red-500 text-6xl mb-4">‚ö†Ô∏è</div>
                            <h2 className="text-2xl font-bold text-gray-800 mb-2">Error</h2>
                            <p className="text-gray-600">{error}</p>
                        </div>
                    </div>
                );
            }

            // Organizar comentarios para mostrar
            const organizedComments = organizeComments(comments);

            return (
                <div className="flex h-screen bg-gray-100">
                    {/* Panel Izquierdo - Visor PDF */}
                    <div className="flex-1 bg-white border-r border-gray-300 flex flex-col">
                        <div className="bg-gray-800 text-white p-4 flex justify-between items-center">
                            <div>
                                <h1 className="text-lg font-semibold">{project?.name}</h1>
                                <p className="text-sm text-gray-300">{project?.pdf_original_name}</p>
                            </div>
                            <div className="flex gap-2">
                                <button 
                                    onClick={exportComments}
                                    className="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm flex items-center gap-1"
                                >
                                    <Download size={16} />
                                    Exportar comentarios
                                </button>
                                {pdfDoc && (
                                    <button 
                                        onClick={() => {
                                            setRenderFailed(false);
                                            renderAllPages(pdfDoc);
                                        }}
                                        className={`px-3 py-1 rounded text-sm ${
                                            renderFailed 
                                                ? 'bg-orange-600 hover:bg-orange-700 animate-pulse' 
                                                : 'bg-blue-600 hover:bg-blue-700'
                                        }`}
                                        disabled={isRendering}
                                    >
                                        {renderFailed ? '‚ö†Ô∏è Re-renderizar PDF' : 'üîÑ Re-renderizar'}
                                    </button>
                                )}
                            </div>
                        </div>

                        <div className="flex-1 overflow-auto bg-gray-100 p-4">
                            {isRendering && (
                                <div className="flex items-center justify-center py-8">
                                    <div className="flex items-center gap-3 text-blue-600">
                                        <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-600"></div>
                                        <span>Cargando p√°ginas del PDF...</span>
                                    </div>
                                </div>
                            )}

                            <div 
                                ref={canvasContainerRef}
                                className="flex flex-col items-center gap-4 max-w-full"
                                style={{ minHeight: isRendering ? '200px' : 'auto' }}
                            >
                            </div>

                            {pdfDoc && renderFailed && !isRendering && (
                                <div className="flex items-center justify-center py-12">
                                    <div className="text-center p-6 bg-yellow-50 border-2 border-yellow-300 border-dashed rounded-lg">
                                        <div className="text-yellow-600 text-3xl mb-3">‚ö†Ô∏è</div>
                                        <div className="text-yellow-800 font-medium text-lg mb-2">PDF cargado pero no visible</div>
                                        <div className="text-yellow-700 mb-3">Haz clic en "Re-renderizar PDF" arriba</div>
                                    </div>
                                </div>
                            )}
                        </div>
                        
                        <div className="bg-gray-50 p-3 border-t text-sm text-gray-600">
                            <div className="flex justify-between items-center">
                                <div>
                                    <span>üìù <strong>Crear comentario:</strong> Clic y arrastra sobre el PDF para seleccionar un √°rea</span>
                                </div>
                                <div className="text-xs text-gray-500">
                                    {pdfDoc && `${totalPages} p√°gina${totalPages !== 1 ? 's' : ''}`}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Panel Derecho - Chat de Comentarios */}
                    <div className="w-96 bg-gray-50 flex flex-col">
                        <div className="bg-purple-600 text-white p-4">
                            <h2 className="text-lg font-semibold flex items-center gap-2">
                                <MessageCircle size={20} />
                                Comentarios del Cliente
                            </h2>
                            <p className="text-purple-100 text-sm">
                                {comments.length} comentario{comments.length !== 1 ? 's' : ''} total
                            </p>
                        </div>

                        {/* Lista de Comentarios */}
                        <div className="flex-1 overflow-y-auto p-4 space-y-3">
                            {organizedComments.length === 0 ? (
                                <div className="text-center text-gray-500 mt-8">
                                    <MessageCircle size={48} className="mx-auto mb-4 text-gray-300" />
                                    <p>No hay comentarios a√∫n</p>
                                    <p className="text-sm">Selecciona un √°rea en el PDF para agregar uno</p>
                                </div>
                            ) : (
                                organizedComments.map((comment, index) => (
                                    <div key={comment.id}>
                                        {/* Comentario principal */}
                                        <div
                                            className={`bg-white rounded-lg p-3 shadow-sm border-l-4 transition-all duration-200 cursor-pointer ${
                                                comment.approved ? 'comment-approved' : ''
                                            } ${
                                                hoveredComment === index ? 'shadow-md scale-105' : ''
                                            }`}
                                            style={{ borderLeftColor: comment.color }}
                                            onMouseEnter={() => setHoveredComment(index)}
                                            onMouseLeave={() => setHoveredComment(null)}
                                            onClick={() => scrollToComment(comment)}
                                        >
                                            <div className="flex justify-between items-start mb-2">
                                                <div className="flex items-center gap-2">
                                                    <span 
                                                        className="inline-block w-6 h-6 rounded-full text-white text-xs flex items-center justify-center font-bold"
                                                        style={{ backgroundColor: comment.color }}
                                                    >
                                                        {index + 1}
                                                    </span>
                                                    {comment.page && totalPages > 1 && (
                                                        <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">
                                                            P√°g. {comment.page}
                                                            <span className="ml-1 text-blue-600">üëÜ Clic para ir</span>
                                                        </span>
                                                    )}
                                                    {comment.approved && (
                                                        <span className="approval-badge">‚úì Aprobado</span>
                                                    )}
                                                </div>
                                                <div className="flex gap-1">
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            setReplyingTo(comment.id);
                                                        }}
                                                        className="text-blue-500 hover:text-blue-700 transition-colors"
                                                        title="Responder"
                                                    >
                                                        <ReplyIcon size={16} />
                                                    </button>
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            startEditComment(index);
                                                        }}
                                                        className="text-blue-500 hover:text-blue-700 transition-colors"
                                                    >
                                                        <Edit3 size={16} />
                                                    </button>
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            deleteComment(index);
                                                        }}
                                                        className="text-red-500 hover:text-red-700 transition-colors"
                                                    >
                                                        <Trash2 size={16} />
                                                    </button>
                                                </div>
                                            </div>
                                            
                                            {editingComment === index ? (
                                                <div className="space-y-2">
                                                    <RichTextEditor
                                                        value={editCommentText}
                                                        onChange={setEditCommentText}
                                                        placeholder="Editar comentario..."
                                                    />
                                                    <div className="flex gap-2 justify-end">
                                                        <button
                                                            onClick={cancelEditComment}
                                                            className="px-3 py-1 text-xs text-gray-600 hover:text-gray-800 transition-colors"
                                                        >
                                                            Cancelar
                                                        </button>
                                                        <button
                                                            onClick={saveEditComment}
                                                            disabled={!editCommentText.trim()}
                                                            className="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                                        >
                                                            Guardar
                                                        </button>
                                                    </div>
                                                </div>
                                            ) : (
                                                <>
                                                    <div className="text-gray-800 mb-2">
                                                        <RichContent content={comment.text} />
                                                    </div>
                                                    <div className="text-xs text-gray-500 mb-2">{comment.timestamp}</div>
                                                    
                                                    {/* Bot√≥n de Aprobado */}
                                                    {!comment.approved && (
                                                        <button
                                                            onClick={(e) => {
                                                                e.stopPropagation();
                                                                approveComment(comment.id);
                                                            }}
                                                            className="w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded font-medium transition-colors flex items-center justify-center gap-2"
                                                        >
                                                            <CheckCircle size={16} />
                                                            Aprobado
                                                        </button>
                                                    )}
                                                </>
                                            )}
                                        </div>

                                        {/* Respuestas */}
                                        {comment.replies && comment.replies.map((reply, replyIndex) => (
                                            <div 
                                                key={reply.id}
                                                className={`comment-reply bg-gray-50 rounded-lg p-3 shadow-sm transition-all duration-200 ${
                                                    reply.approved ? 'comment-approved' : ''
                                                }`}
                                            >
                                                <div className="flex justify-between items-start mb-2">
                                                    <div className="flex items-center gap-2">
                                                        <span className="text-xs bg-gray-300 text-gray-700 px-2 py-1 rounded">
                                                            Respuesta
                                                        </span>
                                                        {reply.approved && (
                                                            <span className="approval-badge">‚úì Aprobado</span>
                                                        )}
                                                    </div>
                                                </div>
                                                <div className="text-gray-800 mb-2">
                                                    <RichContent content={reply.text} />
                                                </div>
                                                <div className="text-xs text-gray-500 mb-2">{reply.timestamp}</div>
                                                
                                                {!reply.approved && (
                                                    <button
                                                        onClick={() => approveComment(reply.id)}
                                                        className="w-full bg-green-600 hover:bg-green-700 text-white py-1 px-3 rounded font-medium transition-colors flex items-center justify-center gap-2 text-sm"
                                                    >
                                                        <CheckCircle size={14} />
                                                        Aprobado
                                                    </button>
                                                )}
                                            </div>
                                        ))}

                                        {/* Formulario de respuesta */}
                                        {replyingTo === comment.id && (
                                            <div className="comment-reply bg-blue-50 rounded-lg p-3">
                                                <div className="mb-2">
                                                    <span className="text-xs text-blue-600 font-medium">Responder a comentario:</span>
                                                </div>
                                                <RichTextEditor
                                                    value={replyText}
                                                    onChange={setReplyText}
                                                    placeholder="Escribe tu respuesta..."
                                                />
                                                <div className="flex gap-2 mt-2 justify-end">
                                                    <button
                                                        onClick={() => {
                                                            setReplyingTo(null);
                                                            setReplyText('');
                                                        }}
                                                        className="px-3 py-1 text-xs text-gray-600 hover:text-gray-800 transition-colors"
                                                    >
                                                        Cancelar
                                                    </button>
                                                    <button
                                                        onClick={() => addComment(comment.id)}
                                                        disabled={!replyText.trim()}
                                                        className="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                                    >
                                                        Responder
                                                    </button>
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                ))
                            )}
                        </div>
                    </div>

                    {/* Dialog para Agregar Comentario */}
                    {showCommentDialog && (
                        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                            <div className="bg-white rounded-lg p-6 max-w-md w-full mx-4">
                                <div className="flex justify-between items-center mb-4">
                                    <h3 className="text-lg font-semibold">Agregar Comentario</h3>
                                    {totalPages > 1 && pendingRect?.page && (
                                        <span className="text-sm bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                            P√°gina {pendingRect.page}
                                        </span>
                                    )}
                                </div>
                                
                                <div className="mb-3 p-3 bg-blue-50 rounded-lg text-sm text-blue-800">
                                    <p className="font-medium mb-1">üí° Puedes usar:</p>
                                    <ul className="text-xs space-y-1">
                                        <li>‚Ä¢ URLs de im√°genes (se mostrar√°n autom√°ticamente)</li>
                                        <li>‚Ä¢ URLs de Google Drive (convertidas a vista directa)</li>
                                        <li>‚Ä¢ URLs de YouTube (se convertir√°n en videos)</li>
                                        <li>‚Ä¢ Usa los botones de formato para texto enriquecido</li>
                                    </ul>
                                </div>

                                <RichTextEditor
                                    value={newComment}
                                    onChange={setNewComment}
                                    placeholder="Escribe tu comentario aqu√≠..."
                                />
                                
                                <div className="flex justify-end gap-3 mt-4">
                                    <button
                                        onClick={() => {
                                            setShowCommentDialog(false);
                                            setPendingRect(null);
                                            setNewComment('');
                                        }}
                                        className="px-4 py-2 text-gray-600 hover:text-gray-800 transition-colors"
                                    >
                                        Cancelar
                                    </button>
                                    <button
                                        onClick={() => addComment()}
                                        disabled={!newComment.trim()}
                                        className="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
                                    >
                                        Agregar Comentario
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // Renderizar la aplicaci√≥n
        ReactDOM.render(<PDFCommentApp />, document.getElementById('root'));
    </script>
</body>
</html>